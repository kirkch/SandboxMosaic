
Q - Question
A - Answer
O - Observation
C - Conclusion


2014
----

Q BitSet vs boolean[]


10 June

  Moving Averages, go parallel or use optimised serial versions?
  The optimised serial version can reduce a moving average down to one addition, subtraction and
  division.

  Results  (measurements for 1 million rows, taken on a haswell quad core mac book pro)

      ma100
      unoptimised serial 127ms
      optimised serial   280ms
      fork join           54ms

      ma5
      unoptimised serial   9ms
      optimised serial    30ms
      fork/join            4ms

  C Going fork/join is faster for ma100.  Eventually ma-X will become faster to be done serially,
    however a quad core laptop was faster brute forcing it for ma100 and we do not yet know of a
    case where we want more than 100 here.  So we will be save using fork/join here.



09 June

  Parallel processing.

  Q When to go parallel, when to stay serial?

  O Columns that have few to no dependencies between other cells can theoretically be divided
    across multiple cores.  Cells with high levels of dependencies are unlikely to benefit, and
    instead often have serial versions of their algorithms that optimise the serial case of
    calculating each row in turn for the same column.  For example, consider moving averages.  When
    averaging say 100 cells, it is possible to calculate the next cell in a series by performing
    just one addition and one subtraction.

    The first spike into going parallel: found that columns that could resize themselves to
       make room for new rows became a bottleneck that make the parallel versions slower than
       the serial version.   NB serial version was 7ms, unthreadsafe forkjoin version 18ms and
       threadsafe/blocking version 78ms.   An efficient use of fork/join, with a column that
       cannot resize itself was able to achieve the same job in only 3ms.

       Thus a design was needed that supported serial algorithms for columns, parallel versions too
       and caching to avoid duplicated effort.

  C    The solution chosen was to split out the following two functions that were previously
       combined with set()/get();  prePopulateColumn(), and resize().

       prePopulateColumn() is for creating a cache.  It was decided not to cache automatically
       as it would cause confusion as to when caching was being used, and that would make updates
       very difficult.  The default implementation uses the fork/join framework to go parallel but
       it can easily be overridden to use more efficient, special case algorithms for columns
       that do not scale well with the fork/join framework.

       resizeIfNecessary() was added so that set() no longer had to check to dynamically resize the columns.
       Thus speeding up both the single threaded cases, and removing a lot of contention from
       the parallel implementation of prePopulateColumn.


4 June 2014

  Column design.  Do we use more OO design to achieve greater code reuse?


  O An alternative approach to the implementations of the Column interface was to move common
    code such as summations, iterations, aggregations to util methods.  However it was shown to
    be 25% slower.  When hotspot was able to inline higher order functions such as AverageAggregator
    then it was just as fast as the inlined approach.  It is a shame that hotspot
    could not do this without help.

  C Inline more code by hand, accepting that code duplication is occurring in payment for extra
    performance.  Aim to do this when there is a measurable benefit.

June Kick off

  Previous spikes have been row based.  Representing the rows, which in Java means objects.  When
  processing a lot of rows, this resulted in a lost of CPU cache misses due to pointer chasing.
  To reduce the misses, Unsafe was used to represent the rows an array of C style structures.  This
  was fast to run, but took longer to write and more care was required in order to prevent mistakes.
  Iterating over rows also caused data other data from the same row to get loaded too, which often
  was not necessary.  It was also found that the code to calculate the rows tended to get scattered
  and more care than I would like was required to keep it clean.

  It was then noted that when most algorithms being implemented only touched a few columns, that
  the most natural place to keep the code was close to that column.  This representation required
  no use of Unsafe to achieve excellent cache hit rates, and it was type safe too.  Unfortunately
  Java generics do not support primitives, so to avoid boxing/unboxing then there is a need for
  a lot of similar classes.