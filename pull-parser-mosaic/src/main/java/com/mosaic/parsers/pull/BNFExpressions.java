package com.mosaic.parsers.pull;

import com.mosaic.lang.Validate;
import com.mosaic.utils.string.CharacterMatcher;
import com.mosaic.utils.string.CharacterMatchers;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 *
 */
public class BNFExpressions {
    public static BNFExpression<String> constant( String targetMatch ) {
        return new MatchCharacterMatcher( CharacterMatchers.constant(targetMatch) );
    }

    public static BNFExpression<String> regexp( String pattern ) {
        return new MatchCharacterMatcher( CharacterMatchers.jdkRegexp( pattern ) );
    }

    /**
     * Requires all supplied expressions to match. If an optional parse is called then only the first expression
     * will be treated as optional (ie lookahead of one). If the first expression matches then all other expressions
     * will be mandatory.
     */
    public static BNFExpression<List> and( BNFExpression... expressions ) {
        return new AndExpression( expressions );
    }

    /**
     * The supplied expression may occur zero or more times.
     */
    public static BNFExpression<List> repeatable( BNFExpression exp ) {
        return new RepeatableExpression( exp );
    }

    /**
     * The supplied expression may occur zero or more times. The exp is separated by the specified separator. Consider
     * a list such as 1,2,3,4
     */
    public static BNFExpression<List> repeatableWithSeparator( BNFExpression exp, BNFExpression separator ) {
        return new RepeatableWithSeparatorExpression( exp, separator );
    }

    public static <T> BNFExpression<T> optional( BNFExpression<T> exp ) {
        return new OptionalExpression( exp );
    }

    public static BNFExpression<String> matches( String s ) {
        return matches( CharacterMatchers.constant( s ) );
    }

    public static BNFExpression<String> matches( CharacterMatcher cm ) {
        return new MatchCharacterMatcher( cm );
    }

    /**
     * Discard the value generated by exp but keep any errors. Replaces the instance of match with null. Thus identifying
     * which values will propagate up the expression tree.
     */
    public static <T> BNFExpression<T> discard( BNFExpression<T> exp ) {
        return new DiscardValueExpression( exp );
    }

    private static final BNFExpression EOF = new ExpectEOFExpression();
    public static <T> BNFExpression<T> eof() {
        return EOF;
    }


    private static class MatchCharacterMatcher extends BNFExpression<String> {
        private CharacterMatcher matcher;

        public MatchCharacterMatcher( CharacterMatcher cm ) {
            this.matcher = cm;
        }

        public <L> Match<String> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            boolean matchedFlag = in.walk( matcher );

            TextPosition pos = in.getPosition();


            Match<String> result;
            if ( matchedFlag ) {
                String matchedText = in.consume();

                result = Match.match( pos, matchedText );
            } else {
                result = Match.none( pos );
            }

            if ( !isOptional && result.isNone() ) {
                result = Match.failedMatch( result.getPos(), String.format("expected '%s'",matcher.description()));
            }

            return result;
        }
    }

    private static class OptionalExpression<T> extends BNFExpression<T> {
        private BNFExpression<T> exp;

        public OptionalExpression( BNFExpression<T> exp ) {
            this.exp = exp;
        }

        public <L> Match<T> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            return exp.parseOptional( runtimeContext, in );
        }
    }

    private static class DiscardValueExpression<T> extends BNFExpression<T> {
        private BNFExpression<T> exp;

        public DiscardValueExpression( BNFExpression<T> exp ) {
            this.exp = exp;
        }

        public <L> Match<T> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            return discardValue( exp.doParse( runtimeContext, in, isOptional ) );
        }

        private Match<T> discardValue( Match<T> m ) {
            if ( m.hasValue() ) {
                return null;
            } else {
                return m;
            }
        }
    }

    private static class ExpectEOFExpression<T> extends BNFExpression<T> {
        public <L> Match<T> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            if ( in.isEOF() ) {
                return Match.none( in.getPosition() );
            } else {
                return Match.failedMatch( in.getPosition(), "expected EOF" );
            }
        }
    }

    private static class AndExpression extends BNFExpression<List> {
        private BNFExpression[] expressions;

        public AndExpression( BNFExpression...expressions ) {
            Validate.isGTZero( expressions.length, "expressions must not be an empty array or null" );

            this.expressions = expressions;
        }

        public <L> Match<List> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            TextPosition startingPosition = in.getPosition();
            int          numExpressions   = expressions.length;
            List         matchedValues    = new ArrayList( numExpressions );

            for ( int i=0; i<numExpressions; i++ ) {
                BNFExpression e = expressions[i];

                Match m = e.parseMandatory(runtimeContext, in);

                if ( m == null ) {                        // skip discarded matches
                    continue;
                } else if ( m.isNone() ) {
                    matchedValues.add( null );

                    continue;
                } else if ( m.isError() ) { // pass errors up the stack
                    if ( isOptional && i == 0 ) { // if the and is itself optional, and the first element is not there then return none
                        return Match.none( m.getPos() );
                    }

                    return m;
                }

                matchedValues.add( m.getValue() );
            }

            return Match.match( startingPosition, matchedValues );
        }
    }

    private static class RepeatableExpression extends BNFExpression<List> {
        private BNFExpression expression;

        public RepeatableExpression( BNFExpression exp ) {
            this.expression = exp;
        }

        public <L> Match<List> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            TextPosition startingPosition = in.getPosition();
            List         matchedValues    = new ArrayList(6);

            Match previousResult = expression.parseOptional( runtimeContext, in );;
            while ( previousResult == null || previousResult.isDefined() ) {
                if ( previousResult != null ) {
                    matchedValues.add( previousResult.getValue() );
                }

                previousResult = expression.parseOptional( runtimeContext, in );
            }

            return previousResult.isError() ? previousResult : Match.match( startingPosition, matchedValues );
        }
    }

    private static class RepeatableWithSeparatorExpression extends BNFExpression<List> {
        private BNFExpression expression;
        private BNFExpression separator;

        public RepeatableWithSeparatorExpression( BNFExpression exp, BNFExpression separator ) {
            this.expression = exp;
            this. separator = separator;
        }

        public <L> Match<List> doParse( L runtimeContext, Tokenizer in, boolean isOptional ) throws IOException {
            TextPosition startingPosition = in.getPosition();
            List         matchedValues    = new ArrayList(6);

            Match previousResult = expression.parseOptional( runtimeContext, in );;
            if ( previousResult == null ) {
                return Match.match( startingPosition, matchedValues );
            } else if ( !previousResult.isDefined() ) {
                return previousResult.isError() ? previousResult : Match.match( startingPosition, matchedValues );
            }

//            use separator
//                once matched the next value is mandatory (will need test)

            matchedValues.add( previousResult.getValue() );

            while ( true ) {
                Match sep = separator.parseOptional( runtimeContext, in );
                if ( sep != null && sep.isDefined() ) {
                    previousResult = expression.parseMandatory( runtimeContext, in );
                } else if ( previousResult != null && previousResult.isError() ) {
                    return previousResult;
                } else {
                    return Match.match( startingPosition, matchedValues );
                }

                if ( previousResult == null ) {
                    // skip discarded values
                } else if (  previousResult.isDefined()) {
                    matchedValues.add( previousResult.getValue() );
                } else if ( previousResult.isError() ) {
                    return previousResult;
                } else {
                    return Match.failedMatch( previousResult.getPos(), "expected next element after separator: " + sep.getValue() );
                }
            }


        }
    }
}